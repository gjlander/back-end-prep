# Subdocuments and going deeper

## ObjectIds

- Because we are using Mongoose, it is automatically converting the `_id` to a string, but it's actual type is `ObjectId`

  - show in Mongo Compass

- This `ObjectId` type is a special Object generated by MongoDB to uniquely identify each document
- It has a `toString` method which is used by Mongoose under the hood to convert it into a string
  - go to [docs](https://www.mongodb.com/docs/manual/reference/method/objectid/)

### Validating ObjectId

- The ObjectId string does follow some rules
  - It is 24 characters long
  - It is hexadecimal (uses 0-9 and A-F to represent 0-15 )
- Because we know the pattern it's supposed to match, we could write a complex regex to test against, but luckily `mongoose` provides a helpful utility function to test if something is a valid Object Id
  - aptly named `isValidObjectId`

#### So we can add a validation check on our dynamic routes to see if it's a valid id

- import it

```js
import { isValidObjectId } from 'mongoose';
```

- `getDuckById`, `updateDuck`, `deleteDuck`

```js
if (!isValidObjectId(id)) throw new Error('Invalid id', { cause: 400 });
```

- add it to our user controllers as well
  - `getUserById`, `updateUser`, `deleteUser`

## Using `lean` to speed up queries

- By default, using Mongoose to query our database it will return an instance of the `Mongoose Document` class
- These can be pretty heavy, much heavier than plain old Vanilla JavaScript objects, because they keep track of internal state, and give us access to all of the class methods to update the document
- For editing (updating or deleting) we need this, but for read-only operations (i.e. GET requests), we don't need this overhead.
- Mongoose gives us the (lean option)[https://mongoosejs.com/docs/tutorials/lean.html] for this
- add it to `getUsers` and `getUserById`

```js
export const getUsers = async (req, res) => {
  const users = await User.find().lean();
  res.json(users);
};

export const getUserById = async (req, res) => {
  const {
    params: { id }
  } = req;
  const user = await User.findById(id).lean();
  if (!isValidObjectId(id)) throw new Error('Invalid id', { cause: 400 });
  if (!user) throw new Error('User not found', { cause: 404 });
  res.json(user);
};
```

- and `getAllDucks` and `getDuckById`
  - goes before `populate`

```js
const getAllDucks = async (req, res) => {
  const ducks = await Duck.find().lean().populate('owner', 'firstName lastName');
  res.json(ducks);
};
const getDuckById = async (req, res) => {
  const { id } = req.params;

  if (!isValidObjectId(id)) throw new Error('Invalid id', { cause: 400 });

  const duck = await Duck.findById(id).lean().populate('owner', 'firstName lastName');

  if (!duck) throw new Error('Duck not found', { cause: 404 });

  res.json(duck);
};
```

## Better password management

### Don't include password with `select: false`

- When we wanted to select all columns except password in SQL we had to list every column we wanted, there was no `exclude this` option
- With `mongoose` there is, we can add `select: false` and then by default the password won't be included when querying our `Users` collection

```js
import { Schema, model } from 'mongoose';

const userSchema = new Schema(
  {
    firstName: { type: String, required: [true, 'First name is required'] },
    lastName: { type: String, required: [true, 'Last name is required'] },
    email: { type: String, required: [true, 'Email is required'], unique: true },
    password: { type: String, required: [true, 'Password is required'], select: false }
  },
  { timestamps: true }
);

export default model('User', userSchema);
```

- We also need to update of Zod schema

```js
const userSchema = z.object({
  firstName: z.string().min(1, 'First name is required.'),
  lastName: z.string().min(1, 'Last name is required.'),
  email: z.email('Invalid email.'),
  password: z.string().min(8)
});
```

- Drop collection, make new user, show lack of password

### Bringing the password back when needed

- Sometimes we do need the password, for example to sign in we want to compare the password and check if it matches the user password
- To include it in a specific query we use the `select` method

```js
export const getUserById = async (req, res) => {
  const {
    params: { id }
  } = req;
  const user = await User.findById(id).select('+password').lean();
  if (!isValidObjectId(id)) throw new Error('Invalid id', { cause: 400 });
  if (!user) throw new Error('User not found', { cause: 404 });
  res.json(user);
};
```

### Using bcrypt to hash password

- We've also thus far been storing passwords as plain text, which is bad practice!
- A database leak would be disastrous, but you also don't want any employee with database access to be able to see all passwords
- To store passwords, we'll use a process called salting and hashing (more to come next week) and a library called `brcypt` to do that for us
- We must `npm i bcrypt`
- import it - `*` means wildcard, we give it an alias

```js
import * as bcrypt from 'bcrypt';
```

- bcrypt has a `hash` method, and we can say how many rounds to put it through, 10 is a good number

```js
export const createUser = async (req, res) => {
  const {
    sanitizedBody: { email, password }
  } = req;

  const found = await User.findOne({ email });

  if (found) throw new Error('Email already exists', { cause: 400 });

  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await User.create({ ...req.sanitizedBody, password: hashedPassword });

  res.json(user);
};
```

- bcrypt also has a `compare` function, but we'll cover that next week when we get to authentication

## Subdocuments

- We've had relatively simple models so far, but a benefit to MongoDB is the ability to embed documents
- With our Mongoose model, this is as simple as creating a nested object
- Let's add a `location` property to our model

```js
const userSchema = new Schema(
  {
    firstName: { type: String, required: [true, 'First name is required'] },
    lastName: { type: String, required: [true, 'Last name is required'] },
    email: { type: String, required: [true, 'Email is required'], unique: true },
    password: { type: String, required: [true, 'Password is required'], select: false },
    location: {
      type: {
        country: String,
        zipCode: String,
        city: String
      },
      default: { country: 'Germany', zipCode: '', city: '' }
    }
  },
  { timestamps: true }
);
```

- And update `zod`

```js
const locationSchema = z
  .object({
    country: z.string(),
    zipCode: z.string(),
    city: z.string()
  })
  .optional();

const userSchema = z.object({
  firstName: z.string().min(1, 'First name is required.'),
  lastName: z.string().min(1, 'Last name is required.'),
  email: z.email('Invalid email.'),
  password: z.string().min(8),
  location: locationSchema
});
```

- Now if we create a user, we see the `location` with default values, and it has it's own `ObjectId`
- Subdocuments have a unique identifier, but they can only exist within the document they are a part of, this is different than populating, where we had a full separate collection, and just populate the data

#### If this feels crowded, we can extract the nested document and make it's own schema

- This would be functionally the exact same

```js
const locationSchema = new Schema({
  country: String,
  zipCode: String,
  city: String
});

const userSchema = new Schema(
  {
    firstName: { type: String, required: [true, 'First name is required'] },
    lastName: { type: String, required: [true, 'Last name is required'] },
    email: { type: String, required: [true, 'Email is required'], unique: true },
    password: { type: String, required: [true, 'Password is required'], select: false },
    location: {
      type: locationSchema,
      default: { country: 'Germany', zipCode: '', city: '' }
    }
  },
  { timestamps: true }
);
```

- As with any other data types, you can set the property to an array of them by simply wrapping in `[]`

### Array of subdocuments with a ref

- Our ducks have a reference to their owner, but the user doesn't reference the ducks, this can stay is it is - we want to save the relationship on one side
- But let's say that we want the ability to have a duck pond, where we can add ducks from other users to our pond
- We can have an array of refs

```js
const userSchema = new Schema(
  {
    firstName: { type: String, required: [true, 'First name is required'] },
    lastName: { type: String, required: [true, 'Last name is required'] },
    email: { type: String, required: [true, 'Email is required'], unique: true },
    password: { type: String, required: [true, 'Password is required'], select: false },
    location: {
      type: locationSchema,
      default: { country: 'Germany', zipCode: '', city: '' }
    },
    myPond: {
      type: [Schema.Types.ObjectId],
      ref: 'Duck',
      default: []
    }
  },
  { timestamps: true }
);
```

- As always, update `zod` too

```js
const userSchema = z.object({
  firstName: z.string().min(1, 'First name is required.'),
  lastName: z.string().min(1, 'Last name is required.'),
  email: z.email('Invalid email.'),
  password: z.string().min(8),
  location: locationSchema,
  myPond: z.array(z.string()).optional()
});
```
